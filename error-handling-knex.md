# Error handling with Knex Queries

## Prior Knowledge

- Able to configure a knex project
- Can run tests against the happy path of a express-knex server
- Knowledge of 400 range status codes

## Learning Objectives

- Catch and handle knex errors
- Build an endpoint with complete error handling using TDD
- Chain error handling middleware for all routes
- Handle requests with invalid methods

## Query Errors

By adding queries to our endpoints we can allow our clients a great deal of customisation in the data the can request.

We utilise TDD to guarantee the behaviour of these queries and ensure that they work correctly. By giving our client this extra customisation with their requests we have also given them several ways to make an incorrect request.

For example, if we have an sort_by query that allows our client to specify the order of the results such as:

`/api/films?sort_by=someColumn`

As this query is user defined it could be a column that doesn't exist

`/api/films?sort_by=someMissingColumn`

**Status 400: bad request.**

## Knex errors

Knex is client agnostic and uses a specified client to run it's SQL queries. In our case `pg`. The same package used in node-pg.

Knex queries support promises, and if the sql throws any errors whilst running the command knex will reject the promise with the error. These errors are generated by the client, so we will get the same errors, codes and messages included, that we received from node-pg.

```js
// models
// request to `/api/films?sort_by=invalid`
exports.fetchFilms = ({ sort_by = 'rating' }) => {
  return connection('films')
    .select('*')
    .orderBy(sort_by, 'asc');
};
// rejects with
// {
//   message: 'column "invalid" does not exist'
//   name: 'error',
//   code: '42703',
//   line: '3294',
//   ...etc
// }
```

These errors can be caught by the controller and sent to an error-handling middleware that will respond appropriately. (See the psql error handling notes for examples of this)

When building our endpoints we should test all of our queries fully, just as we would with any other piece of functionality.
We should consider how our server will respond in the following cases:

- invalid column
- query provides the wrong data type
- not enough information is provided
- too much information is provided
- data is formatted correctly, but is still un-processable? (eg. an id that doesn't exist)

Each of these should be tested and dealt with by generic error-handling middleware. The advantage of this middleware is that once a particular error code is handled, we do not need to repeat it for each endpoint. Nice!

We can use nested describe blocks in our tests to group the methods together and build the functionality as we go.

```js
describe('/films', () => {
  describe('GET', () => {
    it('status:200 responds with an array of <resource_name> objects', () => {
      // test here...
    });
    it('status:200 adds a director key to the film object', () => {
      // test here...
    });
    it('status:200 sorts by rating by default', () => {
      // test here...
    });
    it('status:200 results are ordered by a passed sort_by query', () => 
      // test here...
    });
    it('status:400 for invalid sortBy column', () => {
      // test here...
    });
  });
  describe('POST', () => {
    it('status:201 responds with a created film', () => {
      // test here...
    });
    it('status:400 when posting a value of incorrect type', () => {
      // test here...
    });
    it('status:400 when missing required columns', () => {
      // test here...
    });
    it('status:400 when adding non-existent columns', () => {
      // test here...
    });
    it('status:422 when posting correctly formatted id that does not exist', () => {
      // test here...
    });
  });
  describe('INVALID METHODS', () => {
    // test here...
  });
});
```

## Extra Queries

We will deal with what happens if any of our accepted queries are used in the wrong way. As queries are provided by the client they are free to add any and all that they wish. We should ignore any unsupported queries. For example, they could add the following query that our server is not expecting.

`/api/films?greatFilm=true`

We haven't setup any logic to deal with a greatFilm query. So we should consider what the The standard response is just to ignore any queries that we have not specified and process the request as if it didn't exist. Because we have no control over what queries are provided we shouldn't try and second guess what will happen if they are provided. Nor should we test for this behaviour. It isn't part of our endpoints behaviour and is consistent across the board.

So the above request would just produce the default behaviour of `/api/films`.

## Invalid Methods

In a REST API requests are made to an endpoint using a http method. If we get a request to a valid endpoint but with an invalid method we need to respond accordingly.

When the route exists but we have not permitted for the HTTP method our router will have to respond with `method not allowed`.

### Testing invalid methods

A single request can be tested by returning the supertest promise from our it block. The test is waiting for the resolution of that promise before moving on. To send multiple requests in a single test we can use a return a `Promise.all` invoked with an array of request promises to run them all at the same time.

When we are mapping over the array of `invalidMethods` we are creating a new array of pending promises. Each of these promises is an unresolved request using each particular method in turn.

`request.patch('/api/films')` is equivalent to `request[method]('/api/films')`

```js
describe('INVALID METHODS', () => {
  it('status:405', () => {
    const invalidMethods = ['patch', 'put', 'delete'];
    const methodPromises = invalidMethods.map((method) => {
      return request[method]('/api/films')
        .expect(405)
        .then(({ body: { msg } }) => {
          expect(msg).to.equal('method not allowed');
        });
    });
    // methodPromises -> [ Promise { <pending> }, Promise { <pending> }, Promise { <pending> } ]
    return Promise.all(methodPromises);
  });
});
```

### Status 405: method not allowed

Routers .all method will match any method. As the router matches them in order we can add a .all to the end of our route to send a 405 response on any methods not handled by our controllers.

```js
// routes/films.js
filmsRouter
  .route('/')
  .get(getFilms)
  .all(send405Error);

// errors/index.js
exports.send405Error = (req, res, next) => {
  res.status(405).send({ msg: 'method not allowed' });
};
```